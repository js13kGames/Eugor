<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width"/>
<title>js13k2015</title>
<style>

html,
body
{
	margin: 0; padding: 0;
	background: #000;
	overflow: hidden;
}

canvas
{
	position: fixed;
	left: 0; right: 0;
	top: 0; bottom: 0;
}

</style>
</head>
<body>
<canvas id="Canvas">Sorry, your browser cannot render this content.</canvas>
<script>

"use strict";

var M = Math,
	D = document,
	W = window,
	resources = {
		player: { rect: {/*player*/x:0,y:0,w:16,h:16} },
		wall: { rect: {/*wall*/x:0,y:16,w:16,h:16} },
	},
	level = 0,
	levels = [
		function()
		{
			generate( 16, 16 );
		}],
	atlasWidth,
	atlas,
	canvas,
	ctx,
	resizeTimer,
	width,
	height,
	centerX,
	centerY,
	scaleFactor,
	cellSize,
	sprites = {},
	map = [],
	mapCols,
	mapRows,
	mapWidth,
	mapHeight,
	mapLeft,
	mapTop,
	now,
	factor,
	last,
	viewFirstRow,
	viewFirstCol,
	viewRows,
	viewCols,
	viewX,
	viewY,
	viewOffset,
	viewSkip,
	pointerLength = 0,
	pointerX = [],
	pointerY = [],
	keysDown = [],
	entitiesLength = 0,
	entities = [],
	player;

function reveal( c, r )
{
	r |= 0;
	c |= 0;

	var line = r*mapCols,
		idx = line+M.max( c-2, 0 ),
		last = line+M.min( c+3, mapCols );

	for( ; idx < last; ++idx )
	{
		var t = map[idx];

		if( t.sprite )
			t.visible = true;
	}
}

function addEntity( e )
{
	e.vx = e.vx || 0;
	e.vy = e.vy || 0;

	entities.push( e );
	entitiesLength = entities.length;
}

function setPlayer( c, r )
{
	player = {
		sprite: "player",
		x: c*cellSize,
		y: r*cellSize };

	addEntity( player );
	reveal( c, r );
}

function carve( x, y, w, h )
{
	var o = y*mapCols+x,
		skip = mapCols-w;

	for( var y = h; y--; o += skip )
		for( var e = o+w; o < e; ++o )
			map[o].sprite = sprites.wall;
}

function generate( cols, rows )
{
	entities.length = map.length = 0;

	mapCols = cols;
	mapRows = rows;

	mapWidth = mapCols*cellSize;
	mapHeight = mapRows*cellSize;
	mapLeft = width-mapWidth >> 1;
	mapTop = height-mapHeight >> 1;

	for( var n = cols*rows; n--; )
		map[n] = { visible: true };//false };

	for( var x = 0, y = 0, vx = 1, lw = 0, lh = 0;; )
	{
		var w = 2+(M.random()*8 | 0),
			h = M.max( 1, (M.random() < .5 ? 1 : M.random()*4) | 0 );

		if( vx < 0 )
			x -= w;

		/*if( lh > 0 &&
			M.random() < .2 )
		{
			vx = M.random() > .5 ? -1 : 1;
			y += lh;
			nx = x = M.max( 0, (x+(lw-w)/2) | 0 );
		}*/

		if( x+w >= cols )
		{
			x = cols-w-1;
			y += lh;// lh should be at least 2 here!
			vx = -1;
		}
		else if( x < 0 )
		{
			x = 0;
			y += lh;// lh should be at least 2 here!
			vx = 1;
		}

		if( y+h >= rows )
			break;

		carve( x, y, w, h );

		if( !lh )
			setPlayer( x+w/2, y+h-.5 );

		if( vx > 0 )
			x += w;

		lw = w;
		lh = h;
	}
}

function drawEntities()
{
	for( var n = 0; n < entitiesLength; ++n )
	{
		var e = entities[n],
			s = sprites[e.sprite];

		ctx.drawImage(
			s,
			(mapLeft+e.x-s.centerX) | 0,
			(mapTop+e.y-s.centerY) | 0 );
	}
}

function drawMap()
{
	var idx = viewOffset;

	for( var y = viewY | 0, row = viewFirstRow;
		row < viewRows;
		++row, y += cellSize, idx += viewSkip )
		for( var x = viewX | 0, col = viewFirstCol;
			col < viewCols;
			++col, x += cellSize, ++idx )
		{
			var tile = map[idx];

			if( tile.visible &&
				tile.sprite )
				ctx.drawImage(
					tile.sprite,
					x | 0,
					y | 0 );
		}
}

function draw()
{
	ctx.fillRect( 0, 0, width, height );

	drawMap();
	drawEntities();
}

function calculateVisibleCells()
{
	var l = mapLeft,
		t = mapTop,
		r = l+mapWidth,
		b = t+mapHeight;

	viewFirstRow = 0;
	viewFirstCol = 0;
	viewRows = mapRows;
	viewCols = mapCols;
	viewX = l | 0;
	viewY = t | 0;
	viewOffset = 0;
	viewSkip = 0;

	if( b > height )
		viewRows -= (b-height)/cellSize | 0;

	if( mapTop < 0 )
	{
		var n = t/-cellSize | 0;

		viewOffset += n*mapCols;
		viewY += n*cellSize;
		viewFirstRow += n;
	}

	if( r > width )
	{
		var n = (r-width)/cellSize | 0;

		viewCols -= n;
		viewSkip += n;
	}

	if( l < 0 )
	{
		var n = l/-cellSize | 0;

		viewSkip += n;
		viewOffset += n;
		viewFirstCol = n;
		viewX += n*cellSize;
	}
}

function alignMap()
{
	if( mapWidth > width )
		mapLeft = M.max(
			M.min( 0, centerX-player.x ),
			width-mapWidth );

	if( mapHeight > height )
		mapTop = M.max(
			M.min( 0, centerY-player.y ),
			height-mapHeight );

	calculateVisibleCells();
}

function blocks( x, y )
{
	return y < 0 ||
		y >= mapHeight ||
		x < 0 ||
		x >= mapWidth ||
		!map[(y/cellSize | 0)*mapCols+(x/cellSize | 0)].sprite;
}

function moveBy( e, vx, vy )
{
	var x = e.x,
		y = e.y,
		xs = M.min( 1, vx )*cellSize,
		ys = M.min( 1, vy )*cellSize;

	for( var p = M.abs( vx );
		p > 0 && !blocks( x+xs, y );
		--p, x += xs );

	for( var p = M.abs( vy );
		p > 0 && !blocks( x, y+ys );
		--p, y += ys );

	e.vx = x-e.x;
	e.vy = y-e.y;

	e.x = x;
	e.y = y;
}

function input()
{
	var vx = 0,
		vy = 0,
		step = .03*factor;

	if( pointerLength )
		vx = pointerX[0]-mapLeft < player.x ? -step : step;
	else if( keysDown[37] )
		vx = -step;
	else if( keysDown[39] )
		vx = step;

	if( vx || vy )
	{
		moveBy( player, vx, vy );
		reveal(
			player.x/cellSize,
			player.y/cellSize );
		alignMap();
	}
	else
		player.vx = player.vy = 0;
}

function run()
{
	requestAnimationFrame( run );

	now = Date.now();
	factor = (now-last)/16;
	last = now;

	input();
	draw();
}

function setPointers( ev, down )
{
	var e = ev || event;

	if( down < 1 )
	{
		// process remaining touches
		if( pointerLength > 0 &&
			e.touches &&
			(down = e.touches.length) )
			return setPointers( e, down );

		pointerLength = 0;
	}
	else if( e.touches )
	{
		pointerLength = e.touches.length;

		for( var n = 0; n < pointerLength; ++n )
		{
			var t = e.touches[n];

			pointerX[n] = t.pageX;
			pointerY[n] = t.pageY;
		}
	}
	else if( typeof e.clientX !== "undefined" )
	{
		pointerX[0] = e.clientX;
		pointerY[0] = e.clientY;
		pointerLength = 1;
	}
	else if( typeof e.pageX !== "undefined" )
	{
		pointerX[0] = e.pageX;
		pointerY[0] = e.pageY;
		pointerLength = 1;
	}

	e.preventDefault();
	return false;
}

function pointerUp( ev )
{
	return setPointers( ev, 0 );
}

function pointerMove( ev )
{
	return setPointers( ev, pointerLength );
}

function pointerDown( ev )
{
	return setPointers( ev, 1 );
}

function setKey( ev, pressed )
{
	var e = ev || event;

	keysDown[e.keyCode] = pressed;

	e.preventDefault();
	return false;
}

function keyUp( ev )
{
	return setKey( ev, false );
}

function keyDown( ev )
{
	return setKey( ev, true );
}

function scaleSprite( r )
{
	var rc = r.rect,
		w = M.max( rc.w*scaleFactor | 0, 1 ),
		h = M.max( rc.h*scaleFactor | 0, 1 ),
		c = D.createElement( "canvas" ),
		x = c.getContext( "2d" );

	c.width = w;
	c.height = h;

	c.centerX = w >> 1;
	c.centerY = h >> 1;

	var offset = rc.y*(atlasWidth << 2)+(rc.x << 2),
		skip = (atlasWidth-rc.w) << 2,
		xs = 0,
		xf = scaleFactor;

	if( r.mirror )
	{
		xf = -xf;
		xs = (scaleFactor*rc.w+xf) | 0;
	}

	for( var ay = rc.h, sy = 0;
		ay--;
		offset += skip, sy += scaleFactor )
		for( var ax = rc.w, sx = xs;
			ax--;
			sx += xf )
		{
			var r = atlas[offset++],
				g = atlas[offset++],
				b = atlas[offset++],
				a = atlas[offset++];

			if( a == 0 )
				continue;

			x.fillStyle = 'rgba('+r+','+g+','+b+','+(a/255)+')';
			x.fillRect( sx, sy, scaleFactor, scaleFactor );
		}

	return c;
}

function resize()
{
	canvas.width = width = W.innerWidth;
	canvas.height = height = W.innerHeight;

	centerX = width >> 1;
	centerY = height >> 1;

	cellSize = resources.wall.rect.h;
	scaleFactor = M.max( 1, M.round( M.min( width, height )/70/cellSize ) );
	cellSize *= scaleFactor;

	for( var name in resources )
		sprites[name] = scaleSprite( resources[name] );

	levels[level]();
	alignMap();
}

function scheduleResize()
{
	if( resizeTimer )
		clearTimeout( resizeTimer );

	resizeTimer = setTimeout( resize, 100 );
}

function decompressAtlas()
{
	var c = D.createElement( "canvas" ),
		x = c.getContext( "2d" ),
		w = atlas.width,
		h = atlas.height;

	c.width = w;
	c.height = h;
	x.drawImage( atlas, 0, 0 );

	atlas = x.getImageData( 0, 0, w, h ).data;
	atlasWidth = w;
}

function init()
{
	if( !(canvas = D.getElementById( "Canvas" )) ||
		!(ctx = canvas.getContext( "2d", { alpha: false } )) )
		return;

	ctx.fillStyle = "#000";
	decompressAtlas();

	W.onresize = scheduleResize;
	resize();

	D.onkeydown = keyDown;
	D.onkeyup = keyUp;

	D.onmousedown = pointerDown;
	D.onmousemove = pointerMove;
	D.onmouseup = pointerUp;
	D.onmouseout = pointerUp;

	if( "ontouchstart" in D )
	{
		D.ontouchstart = pointerDown;
		D.ontouchmove = pointerMove;
		D.ontouchend = pointerUp;
		D.ontouchleave = pointerUp;
		D.ontouchcancel = pointerUp;
	}

	last = Date.now()-16;
	run();
}

function load()
{
	/*atlas = new Image();
	atlas.src = "data:image/png;base64,XXXX";
	atlas.onload = init;*/
	atlas = D.createElement( "canvas" );
	var x = atlas.getContext( "2d" );
	x.fillStyle = "#6a9";
	x.fillRect( 0, 0, 16, 16 );
	x.fillStyle = "#265";
	x.fillRect( 0, 16, 16, 16 );
	init();
}

W.onload = load;

</script>
</body>
</html>
