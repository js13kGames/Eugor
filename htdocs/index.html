<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width"/>
<title>js13k2015</title>
<style>

html,
body
{
	margin: 0; padding: 0;
	background: #000;
	overflow: hidden;
}

canvas
{
	position: fixed;
	left: 0; right: 0;
	top: 0; bottom: 0;
}

</style>
</head>
<body>
<canvas id="Canvas">Sorry, your browser cannot render this content.</canvas>
<script>

"use strict";

var M = Math,
	D = document,
	W = window,
	resources = {
		player: { rect: {/*player*/x:0,y:0,w:14,h:14} },
		wall: { rect: {/*wall*/x:0,y:16,w:16,h:16} },
		corridor: { rect: {/*corridor*/x:0,y:32,w:16,h:16} },
		stairs: { rect: {/*stairs*/x:0,y:48,w:16,h:16} },
		entry: { rect: {/*entry*/x:0,y:64,w:16,h:16} },
		exit: { rect: {/*exit*/x:0,y:80,w:16,h:16} },
		enemy: { rect: {/*enemy*/x:0,y:96,w:16,h:16} },
	},
	level = 0,
	levels = [
		function()
		{
			generate( 16, 8 );
		},
		function()
		{
			generate( 24, 16 );
		},
		function()
		{
			generate( 32, 24 );
		},
		],
	atlasWidth,
	atlas,
	canvas,
	ctx,
	resizeTimer,
	width,
	height,
	centerX,
	centerY,
	scaleFactor,
	cellSize,
	sprites = {},
	map = [],
	mapCols,
	mapRows,
	mapWidth,
	mapHeight,
	mapLeft,
	mapTop,
	now,
	factor,
	last,
	viewFirstRow,
	viewFirstCol,
	viewRows,
	viewCols,
	viewX,
	viewY,
	viewOffset,
	viewSkip,
	pointersLength = 0,
	pointersX = [],
	pointersY = [],
	keysDown = [],
	entitiesLength = 0,
	entities = [],
	player;

function reveal( c, r )
{
	c |= 0;
	r |= 0;

	var tp = r*mapCols;

	for( var t = tp;
		t > 0 && map[t+c].sprite;
		t -= mapCols )
		tp = t;

	var lf = tp+M.max( c-2, 0 ),
		rg = tp+M.min( c+3, mapCols ),
		skip = mapCols-(rg-lf);

	for( var stop = (r+1)*mapCols; lf < stop; lf += skip, rg += mapCols )
		for( ; lf < rg; ++lf )
		{
			var t= map[lf];

			if( t.sprite )
				t.visible = true;
		}
}

function tile( c, r )
{
	return map[(r | 0)*mapCols+(c | 0)];
}

function addEntity( e )
{
	e.vx = e.vx || 0;
	e.vy = e.vy || 0;

	entities.push( e );
	entitiesLength = entities.length;
}

function setPlayer( c, r )
{
	player = {
		sprite: "player",
		x: c*cellSize,
		y: (r+1)*cellSize-sprites.player.centerY };

	addEntity( player );
	reveal( c, r );
}

function addEnemy( c, r )
{
	addEntity( {
		sprite: "enemy",
		x: c*cellSize,
		y: r*cellSize } );
}
/*
function carve( l, t, r, b, sprite )
{
	var o = t*mapCols+l,
		w = r-l,
		step = mapCols-w;

	for( var y = b-t; y--; o += step )
		for( var x = w; x--; ++o )
			map[o].sprite = sprite;
}*/
function carve( s, dx, dy )
{
	var l = s.l-dx,
		r = s.r-dx,
		t = s.t-dy,
		b = s.b-dy,
		o = t*mapCols+l,
		w = r-l,
		step = mapCols-w;

	for( var y = b-t; y--; o += step )
		for( var x = w; x--; ++o )
		{
			var m = map[o];

			m.sprite = s.sprite;
			m.stairs = s.stairs;
		}
}

function addSpace( spaces, fl, d, w, h, sprite )
{
	var l = d ? fl.l-w : fl.r,
		t = fl.b-h,
		r = l+w,
		b = t+h;

	fl.l = M.min( fl.l, l );
	fl.r = M.max( fl.r, r );
	fl.t = M.min( fl.t, t );
	fl.b = M.max( fl.b, b );

	spaces.push( { l: l, t: t, r: r, b: b, sprite: sprite } );
}

function generate( rl, el )
{
	var spaces = [],
		average = M.ceil( M.sqrt( rl ) ),
		lastStairs = M.random()*average*8 | 0,
		ml = 0,
		mt = 0,
		mr = 0,
		mb = 0,
		fl = {
			l: 0,
			t: 0,
			r: 0,
			b: 0 };

	for( ;; )
	{
		var first = spaces.length;

		for( var to = rl-M.min(
				rl,
				M.max(
					2,
					M.round( M.random()*average ) ) );
			rl > to;
			--rl )
		{
			var d = false;

			if( spaces.length != first )
			{
				d = M.random() > .5;
				addSpace(
					spaces,
					fl,
					d,
					M.max( 1, M.random()*5 | 0 ),
					1,
					sprites.corridor );
			}

			addSpace(
				spaces,
				fl,
				d,
				M.max( 3, M.random()*9 | 0 ),
				M.max( 2, M.random()*5 | 0 ),
				sprites.wall );
		}

		ml = M.min( ml, fl.l );
		mr = M.max( mr, fl.r );
		mt = M.min( mt, fl.t );
		mb = M.max( mb, fl.b );

		if( rl < 1 )
			break;

		var sl = fl.l+1,
			sr = fl.r-2;

		fl.l = fl.r =
			M.abs( sl-lastStairs ) > M.abs( sr-lastStairs ) ?
			sl : sr;

		lastStairs = fl.l;

		var t = fl.t-M.max( 1, M.random()*3 | 0 );
		spaces.push( {
			l: fl.l,
			t: t,
			r: fl.l+1,
			b: fl.b,
			stairs: true,
			sprite: sprites.stairs } );

		fl.b = t;
	}

	entities.length = map.length = 0;
	mapCols = mr-ml,
	mapRows = mb-mt;

	mapWidth = mapCols*cellSize;
	mapHeight = mapRows*cellSize;
	mapLeft = width-mapWidth >> 1;
	mapTop = height-mapHeight >> 1;

	for( var n = mapCols*mapRows; n--; )
		map[n] = { visible: false };

	for( var n = el, sl = spaces.length; n--; )
	{
		var s;
		while( (s = spaces[M.max( 2, M.random()*sl | 0 )]).stairs );
		s.enemies = s.enemies ? ++s.enemies : 1;
	}

	for( var n = 0, l = spaces.length-1; n <= l; ++n )
	{
		var s = spaces[n],
			e = s.enemies;

		//carve( s.l-ml, s.t-mt, s.r-ml, s.b-mt, s.sprite );
		carve( s, ml, mt );

		if( e > 0 )
		{
			var w = s.r-s.l,
				sp = w/e,
				x = s.l-ml,
				y = s.b-mt-1;

			for( var e = s.enemies; e--; x += sp )
				addEnemy( x+.5, y+.5 );
		}

		if( n == 0 )
		{
			var c = (s.l+s.r >> 1)-ml,
				r = s.b-mt-1;

			map[r*mapCols+c].sprite = sprites.entry;
			tile( c, r ).sprite = sprites.entry;
			setPlayer( c, r );
		}
		else if( n == l )
			tile(
				(s.l+s.r >> 1)-ml,
				s.b-mt-1 ).sprite = sprites.exit;
	}
}

function drawEntities()
{
	for( var n = 0; n < entitiesLength; ++n )
	{
		var e = entities[n],
			s = sprites[e.sprite];

		if( e != player &&
			!map[(e.y/cellSize | 0)*mapCols+(e.x/cellSize | 0)].visible )
			continue;

		ctx.drawImage(
			s,
			(mapLeft+e.x-s.centerX) | 0,
			(mapTop+e.y-s.centerY) | 0 );
	}
}

function drawMap()
{
	var idx = viewOffset;

	for( var y = viewY | 0, row = viewFirstRow;
		row < viewRows;
		++row, y += cellSize, idx += viewSkip )
		for( var x = viewX | 0, col = viewFirstCol;
			col < viewCols;
			++col, x += cellSize, ++idx )
		{
			var t = map[idx];

			if( t.visible &&
				t.sprite )
				ctx.drawImage(
					t.sprite,
					x | 0,
					y | 0 );
		}
}

function draw()
{
	ctx.fillRect( 0, 0, width, height );

	drawMap();
	drawEntities();
}

function calculateVisibleCells()
{
	var l = mapLeft,
		t = mapTop,
		r = l+mapWidth,
		b = t+mapHeight;

	viewFirstRow = 0;
	viewFirstCol = 0;
	viewRows = mapRows;
	viewCols = mapCols;
	viewX = l | 0;
	viewY = t | 0;
	viewOffset = 0;
	viewSkip = 0;

	if( b > height )
		viewRows -= (b-height)/cellSize | 0;

	if( mapTop < 0 )
	{
		var n = t/-cellSize | 0;

		viewOffset += n*mapCols;
		viewY += n*cellSize;
		viewFirstRow += n;
	}

	if( r > width )
	{
		var n = (r-width)/cellSize | 0;

		viewCols -= n;
		viewSkip += n;
	}

	if( l < 0 )
	{
		var n = l/-cellSize | 0;

		viewSkip += n;
		viewOffset += n;
		viewFirstCol = n;
		viewX += n*cellSize;
	}
}

function alignMap()
{
	if( mapWidth > width )
		mapLeft = M.max(
			M.min( 0, centerX-player.x ),
			width-mapWidth );

	if( mapHeight > height )
		mapTop = M.max(
			M.min( 0, centerY-player.y ),
			height-mapHeight );

	calculateVisibleCells();
}

function blocks( x, y )
{
	return y < 0 ||
		y >= mapHeight ||
		x < 0 ||
		x >= mapWidth ||
		!tile( x/cellSize, y/cellSize ).sprite;
}

function moveBy( e, dx, dy )
{
	var x = e.x,
		y = e.y,
		col = x/cellSize,
		row = y/cellSize,
		stairs = tile( col, row ).stairs,
		below = (row | 0)+1,
		s = sprites[e.sprite],
		base = s.centerY,
		baseY = below*cellSize-base,
		bottomY;

	dx *= cellSize*factor;

	if( stairs ||
		(dy > 0 &&
			below < mapRows &&
			tile( col, below ).stairs) ||
		(dy < 0 &&
			y > baseY) )
		dy *= cellSize*factor;
	else
		dy = 0;

	for( var br = below, tl;
		br < mapRows &&
			(tl = tile( col, br )).sprite &&
			!tl.stairs;
		++br )
		++below;

	bottomY = below*cellSize-base;

	var xs = M.min( 1, dx ),
		ys = M.min( 1, dy ),
		cx = s.centerX*.9 | 0,
		cy = s.centerY*.9 | 0,
		l = x-cx,
		r = x+cx,
		t = y-cy,
		b = y+cy;

	for( var nx = M.abs( dx ), ny = M.abs( dy );
		(nx > 0 || ny > 0) &&
			!blocks( l+xs, t+ys ) &&
			!blocks( r+xs, t+ys ) &&
			!blocks( l+xs, b+ys ) &&
			!blocks( r+xs, b+ys );
		--nx, --ny, l += xs, r += xs, t += ys, b+= ys )
	{
		if( nx > 0 )
		{
			x += xs;

			if( y < bottomY &&
				!tile( x/cellSize, y/cellSize ).stairs )
			{
				x -= xs;
				xs = nx = 0;
			}
		}

		if( ny > 0 )
		{
			y += ys;

			if( !stairs &&
				y < baseY )
			{
				y = baseY;
				ys = 0;
			}
		}
	}

	e.dx = dx;
	e.dy = dy;

	e.x = x;
	e.y = y;
}

function input()
{
	var dx = 0,
		dy = 0,
		step = .03*factor;

	if( pointersLength )
	{
		dx = pointersX[0]-mapLeft < player.x ? -step : step;
		dy = pointersY[0]-mapTop < player.y ? -step : step;
	}
	else
	{
		if( keysDown[37] )
			dx = -step;
		else if( keysDown[39] )
			dx = step;

		if( keysDown[38] )
			dy = -step;
		else if( keysDown[40] )
			dy = step;
	}

	if( dx || dy )
	{
		moveBy( player, dx, dy );
		reveal(
			player.x/cellSize,
			player.y/cellSize );
		alignMap();
	}
	else
		player.dx = player.dy = 0;
}

function run()
{
	requestAnimationFrame( run );

	now = Date.now();
	factor = (now-last)/16;
	last = now;

	input();
	draw();
}

function setPointers( ev, down )
{
	var e = ev || event;

	if( down < 1 )
	{
		// process remaining touches
		if( pointersLength > 0 &&
			e.touches &&
			(down = e.touches.length) )
			return setPointers( e, down );

		pointersLength = 0;
	}
	else if( e.touches )
	{
		pointersLength = e.touches.length;

		for( var n = 0; n < pointersLength; ++n )
		{
			var t = e.touches[n];

			pointersX[n] = t.pageX;
			pointersY[n] = t.pageY;
		}
	}
	else if( typeof e.clientX !== "undefined" )
	{
		pointersX[0] = e.clientX;
		pointersY[0] = e.clientY;
		pointersLength = 1;
	}
	else if( typeof e.pageX !== "undefined" )
	{
		pointersX[0] = e.pageX;
		pointersY[0] = e.pageY;
		pointersLength = 1;
	}

	e.preventDefault();
	return false;
}

function pointerUp( ev )
{
	return setPointers( ev, 0 );
}

function pointerMove( ev )
{
	return setPointers( ev, pointersLength );
}

function pointerDown( ev )
{
	return setPointers( ev, 1 );
}

function setKey( ev, pressed )
{
	var e = ev || event;

	keysDown[e.keyCode] = pressed;

	e.preventDefault();
	return false;
}

function keyUp( ev )
{
	return setKey( ev, false );
}

function keyDown( ev )
{
	return setKey( ev, true );
}

function scaleSprite( r )
{
	var rc = r.rect,
		w = M.max( rc.w*scaleFactor | 0, 1 ),
		h = M.max( rc.h*scaleFactor | 0, 1 ),
		c = D.createElement( "canvas" ),
		x = c.getContext( "2d" );

	c.width = w;
	c.height = h;

	c.centerX = w >> 1;
	c.centerY = h >> 1;

	var offset = rc.y*(atlasWidth << 2)+(rc.x << 2),
		skip = (atlasWidth-rc.w) << 2,
		xs = 0,
		xf = scaleFactor;

	if( r.mirror )
	{
		xf = -xf;
		xs = (scaleFactor*rc.w+xf) | 0;
	}

	for( var ay = rc.h, sy = 0;
		ay--;
		offset += skip, sy += scaleFactor )
		for( var ax = rc.w, sx = xs;
			ax--;
			sx += xf )
		{
			var r = atlas[offset++],
				g = atlas[offset++],
				b = atlas[offset++],
				a = atlas[offset++];

			if( a == 0 )
				continue;

			x.fillStyle = 'rgba('+r+','+g+','+b+','+(a/255)+')';
			x.fillRect( sx, sy, scaleFactor, scaleFactor );
		}

	return c;
}

function resize()
{
	canvas.width = width = W.innerWidth;
	canvas.height = height = W.innerHeight;

	centerX = width >> 1;
	centerY = height >> 1;

	cellSize = resources.wall.rect.h;
	scaleFactor = M.max( 1, M.round( M.min( width, height )/70/cellSize ) );
	cellSize *= scaleFactor;

	for( var name in resources )
		sprites[name] = scaleSprite( resources[name] );

	levels[level]();
	alignMap();
}

function scheduleResize()
{
	if( resizeTimer )
		clearTimeout( resizeTimer );

	resizeTimer = setTimeout( resize, 100 );
}

function decompressAtlas()
{
	var c = D.createElement( "canvas" ),
		x = c.getContext( "2d" ),
		w = atlas.width,
		h = atlas.height;

	c.width = w;
	c.height = h;
	x.drawImage( atlas, 0, 0 );

	atlas = x.getImageData( 0, 0, w, h ).data;
	atlasWidth = w;
}

function init()
{
	if( !(canvas = D.getElementById( "Canvas" )) ||
		!(ctx = canvas.getContext( "2d", { alpha: false } )) )
		return;

	ctx.fillStyle = "#000";
	decompressAtlas();

	W.onresize = scheduleResize;
	resize();

	D.onkeydown = keyDown;
	D.onkeyup = keyUp;

	D.onmousedown = pointerDown;
	D.onmousemove = pointerMove;
	D.onmouseup = pointerUp;
	D.onmouseout = pointerUp;

	if( "ontouchstart" in D )
	{
		D.ontouchstart = pointerDown;
		D.ontouchmove = pointerMove;
		D.ontouchend = pointerUp;
		D.ontouchleave = pointerUp;
		D.ontouchcancel = pointerUp;
	}

	last = Date.now()-16;
	run();
}

function load()
{
	/*atlas = new Image();
	atlas.src = "data:image/png;base64,XXXX";
	atlas.onload = init;*/
	atlas = D.createElement( "canvas" );
	atlas.width = 16;
	atlas.height = 112;
	var x = atlas.getContext( "2d" );
	x.fillStyle = "#6a9";
	x.fillRect( 0, 0, 16, 16 );
	x.fillStyle = "#265";
	x.fillRect( 0, 16, 16, 16 );
	x.fillStyle = "#276";
	x.fillRect( 0, 32, 16, 16 );
	x.fillStyle = "#287";
	x.fillRect( 0, 48, 16, 16 );
	x.fillStyle = "#154";
	x.fillRect( 0, 64, 16, 16 );
	x.fillStyle = "#154";
	x.fillRect( 0, 80, 16, 16 );
	x.fillStyle = "#854";
	x.fillRect( 0, 96, 16, 16 );
	init();
}

W.onload = load;

</script>
</body>
</html>
